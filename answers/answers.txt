📝Тест 1
✅ Question 1
	розподілення відповідальності за підтримку певних функцій системи
	📌децентралізовані системи характеризуються відсутністю слабких точок
	наявність незалежних учасників, які разом підтримують її функціонування
	📌ефективність децентралізованих систем завжди вище, ніж централізованих
	📌підтримка та оновлення лише анонімними розробниками

❌ Question 2
	📌децентралізація обов’язково припускає резервування
	📌механізми віддаленого резервування заборонені на законодавчому рівні
	📌децентралізовані технології заохочують нелегальні дії
	резервування не обов’язково припускає децентралізацію
	📌для використання технологій резервування треба мати відповідну ліцензію

❌ Question 3
	Інтернет аукціони
	фінансові облікові системи
	керування персональними даними фізичної особи
	платформи випуску сертифікатів
	соціальні мережі та digital identity
	відкриті реєстри

✅ Question 4
	правила випуску монет задані алгоритмом
	копія бази даних зберігається у всіх
	📌автор криптовалюти контролює обіг монет
	учасники самі обробляють транзакції
	учасники підтримують одні й ті ж самі правила протоколу

❌ Question 5
	обмінники та біржі
	страхові послуги
	автономні банки
	позики під заставу
	📌ринки нерухомості

✅ Question 6
	CryptoKitties
	Axie Infinity
	📌Crash Team Racing
	📌CS:GO
	Decentraland

✅ Question 7
	📌набір інструментів, які призводять до фінансових шахрайств
	📌активність користувачів децентралізованих систем, що поширюється лише на цифрові малюнки
	процес перетворення прав власності або фізичного активу у цифрову форму
	📌метод випуску токенів, що не мають реальної цінності
	📌засіб для фінансових спекуляцій, що винайшли анонімні зловмисники

✅ Question 8
	📌торгівля завжди миттєва, а комісії дорівнюють нулю
	користувачі безпосередньо контролюють свої активи
	ліміти та обмеження на торгову діяльність відсутні
	📌новачкам важко або неможливо її використовувати
	📌угоди завжди займають багато часу та вартують багато комісії

✅ Question 9
	для створення надійного digital identity його треба правильно випускати та перевіряти
	📌digital identity не створює ризиків для приватності користувачів
	identity provider може додавати нові або підтверджувати існуючі атрибути digital identity
	📌digital identity – це просто персональні дані, що завантажені в хмару
	атрибути можуть зберігатися самим користувачем і надаватися ним безпосередньо верифікатору

✅ Question 10
	розподіленість контролю і влади, а також уникнення централізованих посередників
	📌прагнення повністю замінити Web 2.0
	📌створення повністю анонімного середовища
	забезпечення взаємодії різних облікових систем, протоколів і застосунків, щоб створити спільну інфраструктуру
	безпосереднє володіння даними та цифровими активами

📝Тест 2
✅ Question 1
	📌непростежуваність дій користувача, адміністраторів та модераторів системи для будь-яких сторонніх спостерігачів
	📌зведення владних повноважень адміністраторів і власників інформаційної системи в одні руки
	процес розподілу або перерозподілу ресурсів, людей, повноважень, здійснюваних обчислень, збережених даних від єдиного місця розташування або центрального керуючого органу
	📌можливість перевірити, що голос кожного учасника системи було враховано, а результати усіх опитувань опубліковані без підробок
	📌властивість системи функціонувати незалежно, прозоро і з забезпеченням високого рівня анонімності користувачів

✅ Question 2
	наявність єдиної точки відмови
	обмеження пропускної здатності зі стороні сервера
	проблеми при відновленні втраченого набору даних
	схильність до цензури
	📌дешевизна і енергоефективність

✅ Question 3
	📌існує протокол, якого треба притримуватись для роботи в системі
	наявність бази даних, що є спільною для усіх користувачів
	📌автор протоколу контролює усі процеси в системі
	існує алгоритм узгодження кінцевого стану бази даних
	📌відсутній захист від зловмисників, які діють під виглядом користувачів

✅ Question 4
	зберігання даних
	передача даних
	перевірка даних на відповідність правилам
	📌швидкий випуск нових версій протоколу
	управління оновленнями правил протоколу

✅ Question 5
	📌ідентифікатор брокера
	заголовок блоку
	перелік записів (транзакцій)
	📌риночна ціна на валюту
	📌мережева адреса головного комʼютера

✅ Question 6
	зручна перевірка цілісності
	📌швидке і надійне digital identity
	версонування історії змін бази даних
	📌достовірність усіх даних, що записані в базу
	можливість використання легких клієнтів та SPV-вузлів

✅ Question 7
	біржі
	банки
	📌автоматична депортація зрадників
	📌системи ідентифікації депутатів
	📌випуск посвідчень водія

✅ Question 8
	📌використовуватиIPFS для зберігання контенту та підвищення рівня його доступності
	📌використовувати цифрові підписи для аутентифікації кожної транзакції в системі
	📌деанонімізувати більшість зловмисних учасників системи і відʼєднати їх
	узгодити спільне рішення, з яким будуть згодні усі чесні користувачі системи
	📌використовувати механізм сесій для отримання доступу до акаунта з будь-якого пристрою

✅ Question 9
	базова валюта існує від самого початку існування облікової системи
	токени можуть бути випущені будь-яким користувачем в будь-якій кількості
	📌різниці немає, це одне і те саме
	📌монети базової валюти неможливо купити або продати
	📌токени не можуть мати власної ціни

✅ Question 10
	📌так, тому що користувачі не вводять свої персональні дані в застосунок
	ні, тому що дані акаунтів і транзакцій розповсюджуються у відкритому вигляді
	📌так, бо це вимога за замовчуванням, усі децентралізовані системи приватні
	ні, бо приватність користувача включає багато різних аспектів, які складно забезпечити
	📌так, бо відслідкувати та ідентифікувати будь-якого користувача Інтернету неможливо

📝Тест 3
✅ Question 1
	📌хмарний сервіс з технологією шардингу
	📌автоматизоване централізоване середовище для обміну (біржа)
	децентралізована система обліку зі смарт-контрактами
	📌криптовалюта з необмеженою пропускною здатністю для транзакцій
	📌однорангова система передачі даних

✅ Question 2
	📌отримати якомога більше майнингової потужності
	📌купити 256 ethers за біткоїни
	📌зачекати протягом 210’000 блоків
	запустити повний вузол і виконати умови proof-of-stake
	📌створити, підписати та транслювати транзакцію голосування (voting tx)

✅ Question 3
	так, щоб запускати смарт-контракти
	📌ні, незалежних вузлів достатньо
	📌так, щоб запускати код, написаний на Java
	📌ні, смарт-контракти реалізуються нативно
	📌так, щоб зробити процес випуску (монет) можливим

✅ Question 4
	Ethereum – це назва системи обліку
	ether – це назва базової валюти
	одна особа може виступати в якості кількох валідаторів
	кожна дійсна транзакція виконується кожним вузлом
	📌вузли-аудитори не підтримуються в Ethereum 2.0

✅ Question 5
	📌Адам Бэк
	📌Сатоші Накамото
	📌Віталік Бутерін
	Гевін Вуд
	📌Пітер Велле

✅ Question 6
	📌використання мульти-підпису
	📌майнинг за допомогою GPU
	випуск і передача токенів
	📌застосування інструментів для забезпечення високого рівня конфіденційності
	створення та використання DeFi

✅ Question 7
	📌так, кожен новий блок у ланцюжку є остаточним
	📌ні, finality не може бути досягнута в Ethereum 2.0
	📌так, кожен 2048-й блок у ланцюжку є остаточним
	📌ні, finality можлива лише при використання proof-of-work
	так, на глибині 64 блоків finality гарантується

✅ Question 8
	так, авжеж
	📌ні, Ethereum 2.0 не має таких проблем
	📌так, тому що в Ethereum немає приватних транзакцій
	📌ні, оскільки шардинг – це дуже проста технологія
	📌так, тому що ціна на gas є дуже високою

✅ Question 9
	непередбачуваність комісій за транзакції
	📌повільний процес синхронізації mempool
	📌висока вартість обладнання для майнінгу
	модель на основі акаунтів не призначена для конфіденційності
	необхідність користувачам мати базову валюту для роботи з токенами

✅ Question 10
	gas – це платіжна одиниця за виконання транзакцій
	ціна газу (gasPrice) – це кількість ethers, сплачена за одиницю газу
	📌усіма вузлами Ethereum керує лідер спільноти
	смарт-контракти – це запрограмовані правила та умови для управління цінностями в системі
	дані всіх транзакцій і блоків не шифруються

📝Тест 4
❌ Question 1
	📌коли транзакція підписується користувачем
	коли транзакція додається в блок
	📌коли блок додається до ланцюжка
	📌коли валідатор розкриває randao число
	📌коли ціна газу в транзакції менша за ліміт газу

✅ Question 2
	воно виконує роль механізму захисту від повторення транзакції
	📌це застаріле значення, яке зараз не використовується
	📌виконує роль контрольної точки (checkpoint) аккаунта
	щоб відрізняти транзакції одну від одної
	📌для взаємодії зі смарт-контрактами

✅ Question 3
	📌блок вважається недійсним і виключається з ланцюжка
	транзакція повертається (revert)
	📌транзакція виконується до gas limit, а потім припиняється
	📌консенсус на базі PoS не досягається
	📌така транзакція не може бути поширена мережею

❌ Question 4
	📌Unix timestamp
	📌bloom filter подій
	виклик функції смарт-контракту у кодуванні ABI
	байт-код створення смарт-контракту
	📌передача ethers у кодуванні RLP

✅ Question 5
	переказ ether
	📌розгортання порожнього смарт-контракту
	📌переказ USDC
	📌транзакція, яка не перевіряє контрольну суму адреси отримувача
	📌створення облікового запису Ethereum

✅ Question 6
	📌визначається правилами досягнення консенсусу на базі PoS
	📌випадковий
	📌залежить від порядку транзакцій у попередньому блоці
	📌визначається правилами MEV
	визначається поточним валідатором

❌ Question 7
	геш блоку – це ідентифікатор певного стану Ethereum
	вони можуть бути порожніми
	📌вони мають інформацію про весь стан Ethereum
	📌вони використовуються для пошуку повних вузлів мережі
	вони можуть бути реорганізовані за умовами алгоритму досягнення консенсусу

✅ Question 8
	📌постійно змінюється
	залишається незмінним
	дорівнює нулю
	📌залежить від кількості валідаторів
	📌залежить від вибору валідатора

✅ Question 9
	комісія, яку має сплатити транзакція
	📌ether, який буде взято з валідатора
	📌ether, який буде надано валідатору
	спосіб регулювання навантаження на облікову систему
	механізм захисту облікової системи від DOS атаки

✅ Question 10
	коли відповідна епоха пройде валідацію
	📌коли наступна епоха пройде валідацію
	📌вони завжди «безпечні»
	📌вони ніколи не отримують такого статусу
	📌коли блок додається до ланцюжка

📝Тест 5
✅ Question 1
	📌технологія хмарних обчислень з надійною аутентифікацією
	наука про математичні методи забезпечення конфіденційності даних
	📌механізм, який виконує смарт-контракти
	математичні методи, які забезпечують достовірність даних
	📌односпрямована система передачі для симетричного шифрування

✅ Question 2
	односпрямована функція, яка повертає масив байтів постійної довжини
	📌функція, яка використовується для гарантування конфіденційності довільних даних
	📌функція мережі, яка використовувалася для передачі блоків між вузлами
	функція, яка зазвичай може отримати будь-які дані будь-якої довжини на вхід
	📌функція, яка дозволяє оновлювати кеш з часто використовуваними даними

✅ Question 3
	📌SHA-256
	📌CodeJava
	📌Raw-384
	📌AES CBC
	keccak-256

✅ Question 4
	📌адреса в Ethereum – це геш-значення персональних даних користувача
	SHA256 та RIPEMD160 доступні як precompile контракти
	📌кожен користувач може володіти лише одним обліковим записом Ethereum
	криптографічний ключ – це цифрова послідовність певної довжини
	в Ethereum особисті ключі отримують за допомогою генераторів випадкових (або псевдовипадкових) чисел

✅ Question 5
	📌так, кожна адреса смарт-контракту отримується з особистого ключа його власника
	📌ні, кожна адреса Ethereum вибирається користувачем довільним чином
	📌так, кожен смарт-контракт повністю контролюється особистим ключем
	ні, адреса смарт-контракту не відповідає особистому ключу
	📌так, смарт-контракт можна створити лише після генерації для нього пари ключів

❌ Question 6
	така ж, як і у Біткоїні (запропонована Сатоші Накамото)
	📌постквантова
	📌Ethereum не використовує еліптичну криву
	📌спеціальна, для забезпечення приватності в DeFi
	📌secp256k1

✅ Question 7
	📌щоб отримати доступ до мережі
	ентропія гаманця може бути закодована в мнемонічну фразу та декодована з неї в зворотному напрямку
	ентропія з мнемонічної фрази використовується для отримання ключів гаманця
	щоб зробити резервну копію та відновити гаманець за потреби
	📌для перевірки вхідних транзакцій

✅ Question 8
	📌завантаження криптографічної бібліотеки –> генерація пари ключів –> гешування 20 байт особистого ключа –> реєстрація нової адреси
	генерація особистого ключа –> отримання відкритого ключа –> гешування за допомогою Keccak256 –> використання останніх 20 байт гешу як адреси
	📌визначення довжини адреси –> генерація пари ключів –> гешування особистого ключа –> реєстрація нової адреси
	📌підключення цифрового гаманця –> вибір мережі –> завантаження особистого ключа –> оновлення історії транзакцій
	📌запуск повного вузла –> підключення цифрового гаманця –> реєстрація нового облікового запису –> оновлення балансу

✅ Question 9
	📌загальнодоступна хмара, яка видає сертифікати для користувачів
	криптографічна схема, яка дозволяє перевірити цілісність повідомлення
	криптографічна схема, яка дозволяє перевірити автентичність повідомлення
	📌криптографічна схема, яка забезпечує конфіденційність повідомлення
	📌пароль, який можна використовувати необмежену кількість разів

✅ Question 10
	процес отримання відкритого ключа з параметрів v, r, s для отримання адреси акаунту, який підписав транзакцію (або повідомлення)
	📌інтегрований процес повернення транзакцій до mempool у випадку, якщо вони стали непідтвердженими
	📌ініціатива Ethereum Foundation повернути гроші за обладнання для майнінгу після активації The Merge
	📌визначення справжнього імені та прізвища користувача Ethereum шляхом аналізу його активності в мережі
	📌конвертація будь-яких токенів ERC-20 в базову валюту з невеликою комісією

📝Тест 6
✅ Question 1
	📌технологія формування розподіленого сервера за заздалегідь заданими правилами
	📌різні способи оновлення віддалених баз даних
	цифрова незмінна угода, яка привносить концепції та цінності реального світу у цифровий
	📌набір точок концентрації вузлів і специфікація їх поведінки
	детермінована програма, яка виконується в автоматизованій інформаційній системі

❌ Question 2
	мова, на якій написано СК, детерміновано розпізнається комп’ютерами
	📌СК може бути укладений між багатьма сторонами
	📌СК підписується цифровим підписом, який легко перевірити та важко підробити
	людський фактор виключений на етапі виконання
	смарт-контракт можна протестувати

✅ Question 3
	📌зберігають конфіденційність усіх умов і даних контракту
	здійснюють перерозподіл цінностей в залежності від заздалегідь заданих умов
	мінімізують довіру до третіх сторін
	можуть бути перевірені та є незмінними
	📌мають простий процес оформлення порівняно з паперовими договорами

✅ Question 4
	обліковий запис користувача
	📌обліковий запис оракула
	📌обліковий запис аудитора
	обліковий запис контракту
	📌обліковий запис члена спільноти

✅ Question 5
	📌узгодження кінцевого стану -> написання вихідного коду -> генерація транзакції -> поширення транзакції -> генерація адреси контракту
	написання вихідного коду -> компіляція в байт-код -> створення транзакції -> розповсюдження транзакції -> виконання конструктора контракту
	📌вибір контракту зі списку -> компіляція в байт-код -> підписання транзакції -> підтвердження транзакції -> генерація адреси контракту
	📌формування транзакції -> написання вихідного коду -> компіляція байт-коду -> розповсюдження транзакції -> виконання конструктора контракту
	📌генерація адреси контракту -> написання вихідного коду -> компіляція байт-коду -> створення транзакції -> підтвердження транзакції

✅ Question 6
	gasPrice
	gasLimit
	destination
	📌balanceOwner
	signature

✅ Question 7
	📌використовується алгоритм досягнення консенсусу на основі DPoS
	ризик помилитися в коді смарт-контракту
	📌облікові записи з підтримкою мультипідпису
	потенційні вразливості у віртуальній машині
	труднощі прогнозування ціни на gas

✅ Question 8
	📌СК завжди мають одного власника, який може їх оновлювати
	СК зазвичай написані на мовах високого рівня
	СК можуть бути написані довільно або за заздалегідь визначеними шаблонами
	📌СК завжди приватні та зберігають конфіденційність даних
	СК можна запускати в децентралізованому середовищі

✅ Question 9
	📌ні, смарт-контракти ж розумні
	так, через людський фактор
	📌ні, усе можна оновити після розгортання
	📌так, EVM це робить автоматично
	📌ні, тому що середовище виконання децентралізоване

✅ Question 10
	стек і OP-коди
	📌TCP, UDP та DMZ
	сховище смарт-контракту
	returndata як результат виконання
	📌міст між двома системами

📝Тест 7
✅ Question 1
	📌Solidity – це динамічно типізована мова
	📌змінним у Solidity не потрібно вказувати тип
	Solidity – це мова зі статичною типізацією
	для кожної змінної потрібно вказати її тип
	Solidity дозволяє використовувати елементарні типи, які можна комбінувати

❌ Question 2
	📌беззнакові числа зберігаються як Little-Endian
	📌знакові числа зберігаються як Big-Endian з доповненням до 2
	знакові та беззнакові цілі числа мають різні розміри, починаючи з 8 бітів до 256 бітів з кроком 8 бітів
	📌шістнадцяткові числа у змішаному регістрі автоматично розглядаються як літерали адресного типу
	bytesN зберігається як Little-Endian

✅ Question 3
	structs
	arrays
	mappings
	📌bytes32
	string

✅ Question 4
	📌так, завжди
	📌так, але з винятками
	ні, ніколи
	📌тільки з приведенням типів
	📌тільки у двовимірних масивах

❌ Question 5
	структури можуть містити масиви
	структури можуть посилатися на себе
	📌структури мають нескінченний розмір
	присвоєння копіюють структуру
	структури можуть бути значенням в mapping

❌ Question 6
	📌так, і вони повністю підтримуються
	📌ні, їх не існує
	так, але тільки якщо сумуються до цілого числа
	📌так, але їх не можна присвоювати
	📌так, але тільки у base58 записі

❌ Question 7
	📌регістр (register)
	пам’ять (memory)
	📌bytecode контракту
	сховище (storage)
	📌константи та незмінні (constants, immutables)

✅ Question 8
	📌пам'ять (memory) є постійною
	дані виклику (calldata) доступні лише для читання
	📌розмір стека необмежений
	📌константи обчислюються під час розгортання контракту
	значення в сховищі зберігаються після транзакції

❌ Question 9
	storage починається зі слоту 0
	типи значень можуть бути запаковані
	структури завжди починаються з нового слоту
	📌масиви завжди починаються з нового слоту
	елементи uint8 масивів можуть бути запаковані

✅ Question 10
	існують псевдоніми типів даних
	існує режим арифметичних операцій «unchecked»
	📌ділення на нуль дозволено
	📌0**0 (піднесення до ступеню) – це 0
	📌тип адреси займає 30 байтів

📝Тест 8
✅ Question 1
	📌0xf3fef3a34a
	0xf3fef3a3
	📌0x60f62534
	📌withdraw(address,uint256)
	📌withdraw(address,uint256) external

❌ Question 2
	📌publicVar
	📌privateVar
	externalFunction
	publicFunction
	📌internalFunction

✅ Question 3
	view
	payable
	📌onlyOwner
	override
	pure

✅ Question 4
	📌1
	📌2
	📌3
	📌6
	9

❌ Question 5
	📌CREATE2 дозволяє створити два контракти з однаковою адресою одночасно
	CREATE2 використовується для створення контрактів з передбачуваними адресами
	📌CREATE був видалений, починаючи з версії Solidity 0.8.0
	неможливо передбачити адресу контракту, якщо він створений за допомогою OP-коду CREATE
	📌різниці немає, це alias назви

❌ Question 6
	індексовані параметри подій зазвичай використовуються для фільтрації
	📌неанонімні події можуть мати максимум три параметри
	📌анонімні події можуть мати до чотирьох (включно) індексованих параметрів
	динамічні типи не можна використовувати як індексовані параметри
	не індексовані параметри ABI кодуються та додаються в поле data

✅ Question 7
	📌assert використовується для перевірки параметрів, введених користувачем
	revert використовується для повернення користувацьких помилок
	функції require можна додатково передати рядок помилки
	функції revert можна додатково передати рядок помилки
	📌функція require може повертати оголошену користувачем помилку

✅ Question 8
	📌помилки можна перехоплювати за допомогою декількох блоків перехоплення
	після ключового слова try може слідувати створення контракту (наприклад, new Contract())
	📌помилки, що виникають всередині блоку try, можуть бути перехоплені наступним(и) блоком(ами) catch
	щоб перехопити всі випадки помилок, можна використовувати оператор catch { ... }
	помилки типа assert можно перехопити за допомогою catch(Panic(uint256)) { ... }

✅ Question 9
	call може змінювати стан контракту, до якого виконується виклик
	delegatecall зберігає контекст виклику та дозволяє звернутися до коду іншого контракту
	staticcall дозволяє тільки читати дані з контракту, але не може змінювати його стан
	📌delegatecall може викликати функції зі змінними аргументами, тоді як call та staticcall працюють лише з функціями без аргументів
	📌staticcall дозволяє логувати події (events)

✅ Question 10
	uint256
	📌double
	enum
	bool
	bytes32

📝Тест 9
✅ Question 1
	📌stack > memory > calldata > storage
	📌calldata > stack > storage > memory
	stack > calldata > memory > storage
	📌memory > stack > storage > calldata
	📌storage > memory > calldata > stack

✅ Question 2
	📌дозволене тільки для інтерфейсів
	📌дозволене тільки для інтерфейсів та абстрактних контрактів
	дозволене для інтерфейсів та будь-яких контрактів
	📌не дозволене
	📌дозволене лише для абстрактних контрактів

✅ Question 3
	через ключове слово super
	📌просто за назвою функції
	через назву контракту
	📌це неможливо зробити
	📌через ключове слово parent

✅ Question 4
	📌ERC20
	ERC165
	📌ERC4337
	📌ERC712
	📌ERC6224

✅ Question 5
	принцип відкритості / закритості
	принцип інверсії залежності
	📌принцип інкапсуляції даних
	принцип єдиного обов’язку
	принцип Барбари Лісков

✅ Question 6
	у мові Solidity класи є контрактами
	📌є чіткий зв’язок об’єкту з класом
	кожен розгорнутий контракт можна розглядати як об’єкт
	📌з контрактом можна взаємодіяти лише через інтерфейси, які він явно реалізує
	функція контрактів полягає в тому, що вони визначають інтерфейс кодування / декодування ABI для взаємодії між собою

✅ Question 7
	інтерфейси не можуть мати функцій із реалізацією
	📌інтерфейси можуть мати конструктор
	абстрактні контракти не можна розгорнути
	📌інтерфейси не можуть успадковуватися від інших інтерфейсів
	📌інтерфейси можуть мати storage змінні

❌ Question 8
	📌A - B - C - D
	D - C - B - A
	📌A - C - B - D
	📌D - A - B - C
	D - C - B - A

✅ Question 9
	📌d - a - c - b
	a - b - c - d
	📌a - c - b - d
	📌c - b - d - a
	📌d - c - b - a

❌ Question 10
	Solidity підтримує перевизначення функцій
	Solidity підтримує перевантаження функцій
	📌Solidity підтримує перевантаження подій (event)
	Solidity підтримує перевизначення модифікаторів
	📌Solidity підтримує перевантаження модифікаторів

📝Тест 10
✅ Question 1
	📌байт-код смарт-контракту
	інструкція для EVM
	📌код для гешування повідомлення
	один байт
	📌спеціальний код, визначенй EVM, який додається при накладанні цифрового підпису

✅ Question 2
	📌0xF5
	240
	0xFO
	📌128
	📌0x16

✅ Question 3
	дозволяє виконувати оптимізацію програм
	📌додає більше додаткових перевірок в байт-код контракту, за рахунок чого збільшується надійність написаних програм
	використання пам'яті контролює автор написаної програми
	📌використання пам'яті контролює garbage collector можна використовувати лише для оптимізації частини написаної програми
	є окремою low-level мовою програмування

✅ Question 4
	RETURN
	📌RETURNDATASIZE
	📌RETURNDATACOPY
	REVERT
	📌THROW

✅ Question 5
	📌128
	📌256
	📌512
	1024
	📌2048

✅ Question 6
	📌128
	256
	📌512
	📌1024
	📌2048

❌ Question 7
	доступний лише в області видимості функції
	діє по принципу LIFO
	віртуальна машина вказує на конкретні позиції слотів в стеці для отримання даних
	є найдешевшим місцем для розташування даних
	📌якщо використати опкод DUP для зберігання у стек з правильним посиланням, то збережені дані можна використовувати між різними транзакціями

✅ Question 8
	📌набір смарт-контрактів, які керують пам'яттю, зазвичай написаних на Yul
	слоти
	📌соти
	дерев Меркла-Патріції
	📌жорсткі диски

✅ Question 9
	keccak256(1)
	📌sha3(1)
	0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6
	📌1
	📌2

✅ Question 10
	📌розташування даних в стеку схоже на розташуванням даних в пам'яті (memory)
	📌calldata, як правило, використовується для читання, але деякі OP-коди дозволяють проводити процедуру запису
	при виклику смарт-контракту виділяється новий підконтекст calldata та стеку
	аргументи функції, об'явлені як calldata не можуть бути перезаписані в процесі виконання програми
	returndata є послідовним місцем розташування даних

📝Тест 11
✅ Question 1
	📌call
	📌staticall
	delegatecall
	📌проксі працюють не за рахунок OP-кодів
	📌callcode

✅ Question 2
	📌проксі можуть зберігати адресу реалізації в будь-якій змінній
	проксі повинні зберігати адресу реалізації в спеціальному слоті
	📌після виконання функцій інформація записується до storage реалізації
	після виконання функцій інформація записується до storage проксі
	📌проксі повинні мати fallback функцію

✅ Question 3
	функція receive обов’язково повинна бути payable
	📌функція receive не може бути virtual
	функція fallback може бути payable
	функція fallback може бути virtual
	📌функція fallback обов’язково повинна бути payable

✅ Question 4
	є можливість оновлювати реалізації, що дозволяє робити оновлення контрактів
	📌транзакції для взаємодії з контрактами через проксі є дешевшими
	📌системи, які використовують проксі, викликають більше довіри від користувачів
	проксі мають малий байт-код, що дозволяє дешевше їх розгортати
	проксі дозволяють використовувати різні багатофункціональні шаблони розробки платформ

✅ Question 5
	📌деплой проксі контрактів є дорогим
	транзації, які йдуть через проксі, коштують більше для користувачів
	можлива зміна логіки зменшує довіру до контракту
	при оновленні реалізації є можливість «зламати» дані контракту
	📌проксі потрібно використовувати лише для докорінної зміни логіки платформи

✅ Question 6
	📌storage
	external функції
	internal функції
	модифікатори
	📌fallback функції

✅ Question 7
	📌external бібліотеки збільшують байт-код контрактів, де вони використовуються
	📌всі бібліотеки обов’язково потрібно звʼязувати (link) до основних контрактів
	бібліотеки можуть працювати зі storage змінними
	тільки external бібліотеки потрібно звʼязувати (link) до основних контрактів
	📌internal бібліотеки можна викликати лише delegatecall OP-кодом

✅ Question 8
	📌dependencies proxy
	transparent proxy
	diamond proxy
	beacon proxy
	UUPS proxy

✅ Question 9
	не може мати власного storage
	📌функції можуть бути лише internal
	📌функції не можуть приймати storage змінні
	функції викликаються через jump OP-код
	📌обов’язково потрібно окремо розгортати та привʼязувати (link)

✅ Question 10
	📌може мати конструктор
	📌повинна мати тільки external та public функції
	обов’язково потрібно розгортати та привʼязувати (link)
	функції можуть приймати storage змінні
	📌всі функції можна викликати лише за допомогою delegatecall

📝Тест 12
✅ Question 1
	відновлення ESDSA
	гешування даних
	📌операції зі зберіганням даних у розподіленій файловій системі (IPFS)
	операції з великими числами
	📌робота з децентралізованими ідентифікаторами (DID)

✅ Question 2
	📌NETADDR
	ECRECOVER
	RIPEMD160
	ECADD
	IDENTITY

✅ Question 3
	виконання операцій, які вимагають великої обчислювальної потужності
	забезпечення ефективного виконання повторюваних (однакових) операцій
	зниження вартості gas для виконання певних операцій
	збільшення безпеки виконання операцій в Ethereum
	📌розширення можливостей мови програмування Solidity

❌ Question 4
	📌Solidity
	Yul
	мова реалізації вузла Ethereum
	Golang
	Assembly або машиний код

✅ Question 5
	криптографічна схема для перевірки автентичності даних
	📌унікальний ідентифікатор користувача в мережі Ethereum
	📌метод шифрування конфіденційних даних
	📌цифровий відбиток транзакції в обліковій системі
	📌математичний алгоритм для створення ключів шифрування

✅ Question 6
	генерація особистого ключа
	обчислення гешу повідомлення
	📌підписування гешу відкритим ключем
	📌передача відкритого ключа валідаторам системи Ethereum
	підписування гешу особистим ключем

✅ Question 7
	BLS
	📌RSA
	ECDSA
	📌AES
	📌Diffie-Hellman

✅ Question 8
	забезпечує стандартизований формат підпису повідомлення
	робить неможливим випадково підписати транзакцію
	забезпечує більшу безпеку підпису повідомлення
	📌є обов'язковим в Ethereum протоколі
	📌дозволяє ефективніше перевіряти підписані повідомлення

✅ Question 9
	байткоду ініціалізації
	runtime bytecode
	метаданих контракту
	📌адреси власника контракту
	аргументів конструктора

❌ Question 10
	забезпечити кращу безпеку користувачів
	📌зробити cross-chain replay атаки неможливими
	зробити cross-contract replay атаки неможливими
	зробити cross-function replay атаки неможливими
	зробити фішинг атаки неможливими

📝Тест 13
✅ Question 1
	📌Ethereum Request Code
	Ethereum Request for Comments
	📌Ethereum Reserved Contracts
	📌Ethereum Regulated Currencies
	📌Ephemeral Republic of Copycats

✅ Question 2
	ERC20
	📌ERC165
	📌ERC712
	ERC721
	ERC5192

✅ Question 3
	balanceOf
	totalSupply
	transfer
	approve
	📌mint

✅ Question 4
	balanceOf
	ownerOf
	📌transfer
	transferFrom
	📌tokenByIndex

✅ Question 5
	balanceOf
	📌transfer
	📌transferFrom
	📌batchTransferFrom
	📌totalSupply

✅ Question 6
	одночасне управління токенами з різними десятковими (decimals) значеннями
	робота з дефляційними токенами
	робота з неочевидними реалізаціями деяких токенів (наприклад, USDT, WETH)
	📌створення контрактів ERC20 в межах власного контракту
	📌токени можуть зникнути, бо Ethereum не реалізує їх нативно

✅ Question 7
	унікальні, неподільні активи, такі як цифрові предмети колекціонування
	📌взаємозамінні токени, які можна ділити і обмінювати
	власність або права на фізичні активи, такі як нерухомість або твори мистецтва
	унікальні кредити або позиції
	digital identity користувача

✅ Question 8
	ERC721Enumerable
	📌ERC721EnhancedOwnership
	ERC721URIStorage
	📌ERC721DynamicRoyalties
	📌ERC721MerkleTreeWhitelist

✅ Question 9
	токени ERC1155 можуть об'єднувати не тільки токени ERC20, але і токени ERC721
	📌кожен токен, що міститься в ERC1155, вимагає окремої транзакції для передачі
	токени ERC1155 можуть бути передані в контракт тільки в тому випадку, якщо він реалізує певний інтерфейс
	📌токени ERC1155 не можна передавати між контрактами
	📌ERC1155 – це найпопулярніший стандарт токену

✅ Question 10
	SBT – це токен, який не можна передавати
	📌SBT може працювати тільки з zero knowledge proofs
	📌SBT – це концепція лише в рамках Ethereum
	📌SBT працює лише завдяки ERC721
	хто завгодно може випускати SBT

